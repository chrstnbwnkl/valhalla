#!/usr/bin/env python3

import argparse
from collections import namedtuple
from functools import partial
import gzip
import json
import logging
from math import ceil, floor
from multiprocessing import cpu_count
from multiprocessing.dummy import Pool as ThreadPool
from threading import Lock
from pathlib import Path
import sys
from typing import List
from urllib import request
from urllib.error import URLError

description = """Downloads Tilezen's elevation tiles that either intersect with features in all .geojson files in
              --input-geojson-dir or that intersect with --bbox. NOTE: geojson method requires shapely.
              """

# set up the logger basics
LOGGER = logging.getLogger(__name__)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)5s: %(message)s"))
LOGGER.addHandler(handler)

parser = argparse.ArgumentParser(description=description)
method = parser.add_mutually_exclusive_group()
method.add_argument(
    "-g",
    "--geojson-input-dir",
    help="Absolute or relative path to directory with .geojson files used "
    "as input to tile intersection. Requires shapely.",
    type=Path,
)
method.add_argument(
    "-b",
    "--bbox",
    help="Bounding box coordinates in the format 'minX,minY,maxX,maxY'.",
    type=str,
)
parser.add_argument(
    "-c",
    "--config",
    help="Absolute or relative path to the Valhalla config JSON.",
    type=Path,
)
parser.add_argument(
    "-p", "--parallelism", help="Number of processing units to use", type=int
)
parser.add_argument(
    "-d",
    "--decompress",
    help="If set, downloaded files will be decompressed",
    action="store_true",
)
parser.add_argument(
    "-v",
    "--verbosity",
    help="Accumulative verbosity flags; -v: INFO, -vv: DEBUG",
    action="count",
    default=0,
)

Tile = namedtuple("Tile", ["name", "dir"])


def get_tile_info(
    x: int,
    y: int,
) -> Tile:
    hemisphere = "S" if y < 0 else "N"
    dir_name = "%s%02d" % (hemisphere, abs(y))
    tile_name = "%s%02d%s%03d.hgt" % (
        hemisphere,
        abs(y),
        "W" if x < 0 else "E",
        abs(x),
    )

    return Tile(tile_name, dir_name)


def get_tiles_with_shapely(input_dir: Path) -> List[Tile]:
    try:
        from shapely.geometry import Polygon, box
    except ImportError:
        LOGGER.critical(
            "Could not import shapely. Please install shapely or use the --bbox option instead."
        )
        sys.exit(1)

    tile_infos = []
    for coords in get_outer_rings(input_dir):
        poly = Polygon(coords)
        for rect in grid_from_bounds(poly.bounds):
            if poly.intersects(box(*rect)):
                s, w, *_ = rect
                tile_infos.append(get_tile_info(s, w))

    return tile_infos


def get_outer_rings(input_dir: Path) -> List:
    for file in input_dir.glob("*.geojson"):
        with open(file) as f:
            geojson = json.load(f)
        for feature in geojson["features"]:
            if feature["geometry"]["type"] == "Polygon":
                yield feature["geometry"]["coordinates"][0]  # outer ring only
            if feature["geometry"]["type"] == "MultiPolygon":
                for single_polygon in feature["geometry"]["coordinates"]:
                    yield single_polygon[0]  # outer ring only


def grid_from_bounds(bounds: List[float]) -> List[List[int]]:
    """Creates a regular grid of size 1x1 within specified bounds"""
    # loop through x and y range and create the grid
    min_x, min_y = [floor(x) for x in bounds[:2]]
    max_x, max_y = [ceil(x) for x in bounds[-2:]]
    for x in range(min_x, max_x):
        for y in range(min_y, max_y):
            yield [x, y, x + 1, y + 1]


def get_tiles_with_bbox(bbox_str: str) -> List[Tile]:
    try:
        bbox = [float(x) for x in bbox_str.split(",")]
    except ValueError:
        LOGGER.critical(f"BBOX {bbox_str} is not a comma-separated string of coordinates.")
        sys.exit(1)

    if not bbox_is_valid(bbox):
        LOGGER.critical(f"Bbox invalid: {bbox}")
        sys.exit(1)

    LOGGER.debug(f"Received valid bbox: {bbox}")

    tile_infos = []
    for grid in grid_from_bounds(bbox):
        s, w = grid[:2]
        tile_infos.append(get_tile_info(s, w))

    return tile_infos


def bbox_is_valid(bbox):
    min_x, min_y, max_x, max_y = bbox
    if (
        min_x > max_x
        or min_x < -180
        or max_x > 180
        or min_y > max_y
        or min_y < -90
        or max_y > 90
    ):
        return False

    return True


def download(tile: Tile, output_dir, decompress):
    dest_directory = Path(output_dir, tile.dir)

    lock = Lock()
    lock.acquire()
    Path.mkdir(dest_directory, parents=True, exist_ok=True)
    lock.release()

    filepath = Path(dest_directory, tile.name + (".gz" if not decompress else ""))
    if filepath.is_file():
        return False

    url = (
        f"http://s3.amazonaws.com/elevation-tiles-prod/skadi/{tile.dir}/{tile.name}.gz"
    )

    LOGGER.info(f"Downloading tile {tile.name}")
    try:
        with request.urlopen(url) as res, open(filepath, "wb") as f:
            if decompress:
                with gzip.GzipFile(fileobj=res, mode="rb") as gz:
                    f.write(gz.read())
            else:
                f.write(res.read())
            LOGGER.info(f"Successfully downloaded tile {tile.name}")

        return True
    except URLError as e:
        LOGGER.critical(f"Download failed: {e.reason}")

        return False


if __name__ == "__main__":
    args = parser.parse_args()
    with open(args.config) as f:
        config = json.load(f)
    elevation_fp = Path(config["additional_data"]["elevation"] or "elevation")

    # set the right logger level
    if args.verbosity == 0:
        LOGGER.setLevel(logging.CRITICAL)
    elif args.verbosity == 1:
        LOGGER.setLevel(logging.INFO)
    elif args.verbosity >= 2:
        LOGGER.setLevel(logging.DEBUG)

    LOGGER.info(f"Initiating {sys.argv[0]}")

    if args.geojson_input_dir:
        tiles = get_tiles_with_shapely(args.geojson_input_dir)
    elif args.bbox:
        tiles = get_tiles_with_bbox(args.bbox)
    else:
        LOGGER.critical("either --bbox or --geojson-input-dir needs to be specified.")
        sys.exit(1)
    LOGGER.info("Tiles calculated.")

    # create the threadpool and download
    LOGGER.debug("Starting downloads.")
    pool = ThreadPool(args.parallelism or cpu_count())
    results = pool.imap_unordered(
        partial(download, output_dir=elevation_fp, decompress=args.decompress), tiles
    )

    sum_downloaded = list(filter(lambda res: res is True, results))
    LOGGER.info(f"Downloaded {len(sum_downloaded)} tiles. Exiting.")
